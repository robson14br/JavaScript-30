<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
  <link rel="icon" href="https://fav.farm/üî•" />
</head>
<body>

  <script>
    // In√≠cio do script JavaScript

    // Exemplo com strings, n√∫meros e booleanos:
    // Declaramos uma vari√°vel 'name' com valor 'robs'
    // let name = 'robs';
    // Em seguida, copiamos o valor de 'name' para 'name2'
    // let name2 = name;
    // Mostramos no console os valores de 'name' e 'name2'
    // console.log(name, name2);
    // Atualizamos o valor de 'name' para 'raires'
    // name = 'raires';
    // Agora mostramos os valores novamente para ver a diferen√ßa
    // console.log(name, name2);

    // Vamos trabalhar com arrays agora
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    // Queremos fazer uma c√≥pia do array 'players'
    const team = players;

    // Exibimos no console os valores de 'players' e 'team'
    console.log(players, team);

    // Podemos pensar que a atribui√ß√£o direta cria uma c√≥pia do array
    // Atualizamos o √∫ltimo elemento de 'team' para 'Lux'
    team[3] = 'Lux';

    // Por√©m, ao atualizar 'team', o array original 'players' tamb√©m √© alterado
    // Isto ocorre porque 'team' n√£o √© uma c√≥pia, mas sim uma refer√™ncia ao mesmo array na mem√≥ria

    // Para resolver isso, precisamos fazer uma c√≥pia real do array
    // Podemos usar o m√©todo 'slice()' para criar uma c√≥pia do array
    const team2 = players.slice();

    // Outra forma √© criar um novo array e concatenar o antigo
    const team3 = [].concat(players);

    // Ou podemos usar o novo operador Spread (ES6) para criar uma c√≥pia
    const team4 = [...players];

    // Agora, se atualizarmos algum dos novos arrays, o array original 'players' n√£o ser√° alterado

    // O mesmo conceito se aplica para objetos
    const person = {
      name: 'Wes Bos',
      age: 80
    };

    // Aqui, 'captain' √© uma refer√™ncia ao objeto 'person'
    const captain = person;
    // Ao adicionar uma nova propriedade 'number' em 'captain', estamos tamb√©m alterando o objeto 'person'
    captain.number = 99;

    // Para fazer uma c√≥pia real do objeto, podemos usar 'Object.assign'
    // Isso cria um novo objeto e copia todas as propriedades de 'person', al√©m de adicionar/alterar as propriedades especificadas
    const cop2 = Object.assign({}, person, {number: 99, age: 12});
    console.log(cop2);

    // Outra forma de copiar objetos √© utilizando o operador Spread (ES6)
    const cap3 = {...person};

    // Importante notar: As c√≥pias realizadas por essas t√©cnicas s√£o superficiais, ou seja, elas s√≥ copiam o primeiro n√≠vel de propriedades.
    // Para c√≥pias profundas (deep clone), onde todos os n√≠veis do objeto/array s√£o copiados, pode-se utilizar uma biblioteca como lodash com o m√©todo cloneDeep, mas √© preciso ter cautela ao us√°-lo.
  </script>

</body>
</html>
